@{
    Layout = "~/Views/Shared/_LayoutGameDev.cshtml";
}

<canvas id="arkanoid-canvas" width="800" height="600"></canvas>

@section Scripts {
    <script type="text/javascript">
        var arkanoidCanvas;
        var canvasContext;

        // canvas dimensions
        var canvasWidth  = 800;
        var canvasHeigth = 600;

        // paddle
        var paddle1X                    = 350;
        const PADDLE_THICKNESS          = 10;
        const PADDLE_DISTANCE_FROM_EDGE = 60;
        const PADDLE_WIDTH              = 100;

        // ball
        var ballRadius   = 10;
        var ballX        = canvasWidth / 2;
        var ballY        = canvasHeigth / 2;
        var ballSpeedX   = 5;
        var ballSpeedY   = 5;
        var ballSpeedPct = 0.35;

        // mouse 
        var mouseX = 0;
        var mouseY = 0;

        // bricks
        const BRICK_W = 50;
        const BRICK_H = 10;
        const BRICK_N = 10;

        //var brick1 = true;
        //var brick2 = false;
        //var brick3 = true;
        //var brick4 = true;
        //var brickGrid = [brick1, brick2, brick3, brick4];
        var brickGrid = new Array(BRICK_N);
        


        $(function () {
            arkanoidCanvas = $("#arkanoid-canvas");
            canvasContext  = arkanoidCanvas[0].getContext('2d');

            canvasWidth  = arkanoidCanvas.width();
            canvasHeigth = arkanoidCanvas.height();

            // draw multiple time: simulate movement
            var framesPerSecond = 60;
            setInterval(callCanvasFunctions, 1000 / framesPerSecond);

            // add mouse events
            arkanoidCanvas.mousemove(function (evt) {
                var mousePos = calculateMousePos(evt);
                paddle1X     = mousePos.x - (PADDLE_WIDTH / 2);
            });

            // reset bricks
            brickReset();
        });

        function calculateMousePos(evt) {
            var rect = arkanoidCanvas[0].getBoundingClientRect();
            var root = document.documentElement;
            mouseX   = evt.clientX - rect.left - root.scrollLeft;
            mouseY   = evt.clientY - rect.top - root.scrollTop;
            return {
                x: mouseX,
                y: mouseY
            };
        }

        function callCanvasFunctions() {
            moveInCanvas();
            drawInCanvas();
        }

        function brickReset() {
            for (var i = 0; i < brickGrid.length; i++) {
                brickGrid[i] = true;
            }

            var randomHiddenBrick = ((BRICK_N - 1) * Math.random()).toFixed();
            brickGrid[randomHiddenBrick] = false;
        }

        function ballReset() {
            //ballSpeedX = -ballSpeedX;
            //ballSpeedY = -ballSpeedY;

            ballX = canvasWidth / 2;
            ballY = canvasHeigth / 2;
        }

        function moveInCanvas() {
            // ball
            ballX += ballSpeedX;
            ballY += ballSpeedY;

            if (ballX < 0) { // left
                ballSpeedX *= -1;
            }

            if (ballX > canvasWidth) { // right
                ballSpeedX *= -1;
            }

            if (ballY < 0) { // top
                ballSpeedY *= -1;
            }

            if (ballY > canvasHeigth) { // bottom
                ballReset();
                //ballSpeedY *= -1;
            }

            // paddle
            var paddleTopEdgeY    = canvasHeigth - PADDLE_DISTANCE_FROM_EDGE;
            var paddleBottomEdgeY = paddleTopEdgeY + PADDLE_THICKNESS;
            var paddleLeftEdgeX   = paddle1X;
            var paddleRightEdgeX  = paddleLeftEdgeX + PADDLE_WIDTH;

            if(ballY > paddleTopEdgeY && // below the top of the paddle
                ballY < paddleBottomEdgeY && // above bottom of paddle
                ballX > paddleLeftEdgeX &&  // right of left side of paddle
                ballX < paddleRightEdgeX) { // left of the rigth side of paddle
                ballSpeedY *= -1;

                // 
                var centerOfPaddleX = (paddle1X + PADDLE_WIDTH / 2);
                var ballDistanceFromPaddleCenterX = ballX - centerOfPaddleX;
                ballSpeedX = ballDistanceFromPaddleCenterX * ballSpeedPct;
            }
        }

        function drawInCanvas() {
            // background rectagle
            colorRect(0, 0, canvasWidth, canvasHeigth, 'black');

            // paddel
            colorRect(paddle1X, canvasHeigth - PADDLE_DISTANCE_FROM_EDGE, PADDLE_WIDTH, PADDLE_THICKNESS, 'white');

            // ball
            colorCircle(ballX, ballY, ballRadius, 'blue');

            drawBricks();

            // print mouse position
            colorText(mouseX + "," + mouseY, mouseX, mouseY, "yellow");
        }

        function drawBricks() {
            
            // display individual bicks
            //if(brick1) {
            //    colorRect(0, 0, BRICK_W, BRICK_H, 'red');
            //}
            //if (brick2) {
            //    colorRect(BRICK_W + 5, 0, BRICK_W, BRICK_H, 'red');
            //}
            //if (brick3) {
            //    colorRect(BRICK_W * 2 + 5 * 2, 0, BRICK_W, BRICK_H, 'red');
            //}
            //if (brick4) {
            //    colorRect(BRICK_W * 3 + 5 * 3, 0, BRICK_W, BRICK_H, 'red');
            //}

            // display bricks row
            for (var i = 0; i < brickGrid.length; i++) {
                if (brickGrid[i]) {
                    colorRect(BRICK_W * i + 5 * i, 0, BRICK_W, BRICK_H, 'red');
                } // end of is this brick visible
            } // end of for each display brick
        } // end of drawBricks function

        // shapes helper functions
        function colorRect(leftX, topX, width, heigth, color) {
            canvasContext.fillStyle = color;
            canvasContext.fillRect(leftX, topX, width, heigth);
        }

        function colorCircle(leftX, topX, radius, color) {
            canvasContext.fillStyle = color;
            canvasContext.beginPath();
            canvasContext.arc(leftX, topX, radius, 0, Math.PI * 2, true);
            canvasContext.fill();
        }

        function colorText(textString, textX, textY, fillColor) {
            canvasContext.fillStyle = fillColor;
            canvasContext.fillText(textString, textX, textY);
        }

    </script>
}