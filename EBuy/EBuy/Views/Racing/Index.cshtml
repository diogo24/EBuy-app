
@{
    ViewBag.Title = "Index";
    Layout        = "~/Views/Shared/_LayoutGameDev.cshtml";
}

<canvas id="racing-canvas" width="800" height="600"></canvas>

@section Scripts {
    <script type="text/javascript">
        var racingCanvas;
        var canvasContext;

        // canvas dimensions
        var canvasWidth  = 800;
        var canvasHeigth = 600;

        // ball
        var ballRadius   = 10;
        var ballX        = canvasWidth / 2;
        var ballY        = canvasHeigth / 2;
        var ballSpeedX   = 5;
        var ballSpeedY   = 5;
        var ballSpeedPct = 0.35;

        // mouse 
        var mouseX = 0;
        var mouseY = 0;

        // track
        const TRACK_W    = 40;
        const TRACK_H    = 40;
        const TRACK_COLS = 20;
        const TRACK_ROWS = 15;
        const TRACK_GAP  = 5;
        var tracksLeft   = 0;

        //var track1 = true;
        //var track2 = false;
        //var track3 = true;
        //var track4 = true;
        //var trackGrid = [track1, track2, track3, track4];
        var trackGrid = new Array(TRACK_ROWS);

        $(function () {
            racingCanvas = $("#racing-canvas");
            canvasContext = racingCanvas[0].getContext('2d');

            canvasWidth = racingCanvas.width();
            canvasHeigth = racingCanvas.height();

            // draw multiple time: simulate movement
            var framesPerSecond = 60;
            setInterval(callCanvasFunctions, 1000 / framesPerSecond);

            // add mouse events
            racingCanvas.mousemove(function (evt) {
                var mousePos = calculateMousePos(evt);
                // cheat/hack to test ball in any position
                //ballX = mouseX;
                //ballY = mouseY;
                //ballSpeedX = 4;
                //ballSpeedY = -4;
            });

            // reset tracks
            trackReset();
            ballReset();
        });

        function calculateMousePos(evt) {
            var rect = racingCanvas[0].getBoundingClientRect();
            var root = document.documentElement;
            mouseX = evt.clientX - rect.left - root.scrollLeft;
            mouseY = evt.clientY - rect.top - root.scrollTop;
            return {
                x: mouseX,
                y: mouseY
            };
        }

        function callCanvasFunctions() {
            moveInCanvas();
            drawInCanvas();
        }

        function trackReset() {
            for (var rowIdx = 0; rowIdx < TRACK_ROWS; rowIdx++) {
                trackGrid[rowIdx] = new Array(TRACK_COLS);
                for (var colIdx = 0; colIdx < TRACK_COLS; colIdx++) {
                        trackGrid[rowIdx][colIdx] = true;
                        tracksLeft++;
                    }

            }
        }

        function ballReset() {
            //ballSpeedX = -ballSpeedX;
            //ballSpeedY = -ballSpeedY;

            ballX = canvasWidth / 2;
            ballY = canvasHeigth / 2;
        }

        function moveInCanvas() {
            ballMove();

            ballTrackHandling();
        }

        function ballMove() {
            // ball
            ballX += ballSpeedX;
            ballY += ballSpeedY;

            if (ballX < 0 && ballSpeedX < 0.0) { // left
                ballSpeedX *= -1;
            }

            if (ballX > canvasWidth && ballSpeedX > 0.0) { // right
                ballSpeedX *= -1;
            }

            if (ballY < 0 && ballSpeedY < 0.0) { // top
                ballSpeedY *= -1;
            }

            if (ballY > canvasHeigth) { // bottom
                //ballSpeedY *= -1;
                ballReset();
                trackReset();
            }
        }

        function ballTrackHandling() {
            // ball position in the grid
            var ballTrackCol = Math.floor(ballX / TRACK_W);
            var ballTrackRow = Math.floor(ballY / TRACK_H);

            // remove tracks with ball
            if (ballTrackCol >= 0
                && ballTrackCol < TRACK_COLS
                && ballTrackRow >= 0
                && ballTrackRow < TRACK_ROWS) {

                // remove track and change ball direction
                if (trackGrid[ballTrackRow] && trackGrid[ballTrackRow][ballTrackCol]) {
                    trackGrid[ballTrackRow][ballTrackCol] = false;
                    tracksLeft--;
                    //ballSpeedY *= -1;             

                    var prevBallX = ballX - ballSpeedX;
                    var prevBallY = ballY - ballSpeedY;
                    var prevTrackCol = Math.floor(prevBallX / TRACK_W);
                    var prevTrackRow = Math.floor(prevBallY / TRACK_H);

                    // ball boucing from tracks version 1
                    //if (prevTrackCol != ballTrackCol) {
                    //    ballSpeedX *= -1;
                    //}

                    //if (prevTrackRow != ballTrackRow) {
                    //    ballSpeedY *= -1;
                    //}


                    var bothTestsFailed = true;
                    // ball boucing from tracks version 2
                    // bouce ball ajusted to adjacent tracks
                    if (prevTrackCol != ballTrackCol) {

                        // adjacent track sides
                        if (!trackGrid[ballTrackRow] || trackGrid[ballTrackRow][prevTrackCol] == false) {
                            ballSpeedX *= -1;
                            bothTestsFailed = false;
                        }
                    }

                    if (prevTrackRow != ballTrackRow) {

                        // adjacent track top bottom
                        if (!trackGrid[prevTrackRow] || trackGrid[prevTrackRow][ballTrackCol] == false) {
                            ballSpeedY *= -1;
                            bothTestsFailed = false;
                        }
                    }

                    // armpit case
                    if (bothTestsFailed) {
                        ballSpeedX *= -1;
                        ballSpeedY *= -1;
                    }

                } // end of track found
            } // end of valid col and row
        } // end of ballTrackHandling func

        function drawInCanvas() {
            // background rectagle
            colorRect(0, 0, canvasWidth, canvasHeigth, 'black');

            // ball
            colorCircle(ballX, ballY, ballRadius, 'blue');

            drawTracks();

            // mouse position in the grid
            var mouseTrackCol = Math.floor(mouseX / TRACK_W);
            var mouseTrackRow = Math.floor(mouseY / TRACK_H);

            // print mouse position
            //colorText(mouseX + "," + mouseY, mouseX, mouseY, "yellow");
            colorText(mouseTrackCol + "," + mouseTrackRow, mouseX, mouseY, "yellow");

            // remove track with mouse
            //if(mouseTrackCol >= 0
            //    && mouseTrackCol < TRACK_COLS
            //    && mouseTrackRow >= 0
            //    && mouseTrackRow < TRACK_ROWS) {
            //    trackGrid[mouseTrackRow][mouseTrackCol] = false;
            //}
        }

        function drawTracks() {

            // display individual bicks
            //if(track1) {
            //    colorRect(0, 0, TRACK_W, TRACK_H, 'red');
            //}
            //if (track2) {
            //    colorRect(TRACK_W + 5, 0, TRACK_W, TRACK_H, 'red');
            //}
            //if (track3) {
            //    colorRect(TRACK_W * 2 + 5 * 2, 0, TRACK_W, TRACK_H, 'red');
            //}
            //if (track4) {
            //    colorRect(TRACK_W * 3 + 5 * 3, 0, TRACK_W, TRACK_H, 'red');
            //}

            // display tracks row
            //for (var i = 0; i < trackGrid.length; i++) {
            //    if (trackGrid[i]) {
            //        colorRect(TRACK_W * i, 0, TRACK_W - TRACK_GAP, TRACK_H - TRACK_GAP, 'red');
            //    } // end of is this track visible
            //} // end of for each display track

            //for (var i = 0; i < trackGrid.length; i++) {
            //    if (trackGrid[i]) {
            //        colorRect(TRACK_W * i, TRACK_H, TRACK_W - TRACK_GAP, TRACK_H - TRACK_GAP, 'red');
            //    } // end of is this track visible
            //} // end of for each display track

            // display tracks grid
            for (var rowIdx = 0; rowIdx < TRACK_ROWS; rowIdx++) {
                for (var colIdX = 0; colIdX < TRACK_COLS; colIdX++) {
                    if (trackGrid[rowIdx][colIdX]) {
                        //colorRect(TRACK_W * colIdX, TRACK_H * rowIdx, TRACK_W - TRACK_GAP, TRACK_H - TRACK_GAP, 'red');
                        colorRect((TRACK_W * colIdX), (TRACK_H * rowIdx), TRACK_W - TRACK_GAP, TRACK_H - TRACK_GAP, 'red');
                    } // end of is this track visible
                } // end of for each display track
            }
        } // end of drawTracks function

        // shapes helper functions
        function colorRect(leftX, topX, width, heigth, color) {
            canvasContext.fillStyle = color;
            canvasContext.fillRect(leftX, topX, width, heigth);
        }

        function colorCircle(leftX, topX, radius, color) {
            canvasContext.fillStyle = color;
            canvasContext.beginPath();
            canvasContext.arc(leftX, topX, radius, 0, Math.PI * 2, true);
            canvasContext.fill();
        }

        function colorText(textString, textX, textY, fillColor) {
            canvasContext.fillStyle = fillColor;
            canvasContext.fillText(textString, textX, textY);
        }

    </script>
}